import { writeFileSync } from "node:fs";
import { join, relative, resolve } from "node:path";
import { fileURLToPath } from "node:url";
import { loadPromptLibrary } from "../lib/prompts/loader";

const scriptPath = fileURLToPath(import.meta.url);
const scriptDir = resolve(scriptPath, "..");
const backendRoot = resolve(scriptDir, "..");
const libraryDir = join(backendRoot, "lib/prompts/library");
const outputFile = join(backendRoot, "lib/prompts/prompts.generated.ts");

const { prompts, errors, warnings } = loadPromptLibrary(libraryDir);

if (warnings.length > 0) {
  for (const warning of warnings) {
    console.warn(`[prompts] ${warning}`);
  }
}

if (errors.length > 0) {
  for (const error of errors) {
    console.error(`[prompts] ${error}`);
  }
  process.exit(1);
}

const sorted = prompts.sort((a, b) => a.id.localeCompare(b.id));
const entries = sorted.map((prompt) => {
  const sourcePath = relative(libraryDir, prompt.path).replace(/\\/g, "/");
  const record = {
    id: prompt.id,
    title: prompt.title,
    version: prompt.version,
    role: prompt.role,
    purpose: prompt.purpose,
    tags: prompt.tags,
    diagramType: prompt.diagramType,
    outputSchemaId: prompt.outputSchemaId,
    variables: prompt.variables,
    variantOf: prompt.variantOf,
    sourcePath,
    body: prompt.body,
  };

  const json = JSON.stringify(record, null, 2).replace(/\n/g, "\n  ");
  return `  ${JSON.stringify(prompt.id)}: ${json}`;
});

const ids = sorted.map((prompt) => JSON.stringify(prompt.id)).join(", ");

const contents = `// This file is generated by scripts/generate-prompts.ts.
// Do not edit by hand.
import type { PromptRecord } from "./types";

export const PROMPT_IDS = [${ids}] as const;

export type PromptId = (typeof PROMPT_IDS)[number];

const PROMPTS_DATA = {
${entries.join(",\n")}
} as const satisfies Record<PromptId, PromptRecord>;

export const PROMPTS: Record<PromptId, PromptRecord> = PROMPTS_DATA;
`;

writeFileSync(outputFile, contents, "utf8");
console.log(`[prompts] wrote ${outputFile}`);
